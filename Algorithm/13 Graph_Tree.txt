<그래프>

그래프는 객체들 사이의 관계를 표현하기 위한 것이다.
1. 관계가 있으면 연결
2. 방향성이 있는 관계 => 화살표로 표시
3. 관계에 표현하고 싶은 정보가 있다면 간선 옆에 적으면 되고, 이를 가중치라 한다.

간선의 정보만 있다면 그래프 복구가 가능하다.

<트리>

그래프 중 하나의 노드를 들어올려서 root가 정해지면 tree다.
사이클이 있으면 안된다.
서로 다른 자식은 부모가 둘 이상은 안된다.

depth는 Node, 높이는 tree 입장이다. (0부터 시작한다)
어떤 노드 기준으로 위는 조상 아래에 있는 모든 것이 자손이다.

트리는 DFS로 순회하면서 3가지를 한번에 구할 수 있다.
1. 각 노드의 부모 노드 int par[n+1];
2. 각 노드의 깊이 int depth[n+1];
3. 각 노드가 기준일 때, 서브트리 노드 수 int sz[n+1];

int n;
vector<int> v(n + 1);

void dfs(int cur, int prv) { => 그래프가 아닌 트리는 방문처리를 걱정할 필요가 없다. 위로 올라가지 않기 때문에
    sz[cur] = 1;
    par[cur] = prv;
    for(auto nxt : v[cur]) {
        if (nxt == prv) continue; // 무향 그래프라면 만날 수 있다.
        depth[nxt] = depth[cur] + 1;
        dfs(nxt, cur);
        sz[cur] += sz[nxt];
    }
}

dfs(root, -1);

위와 같은 방식으로 부모 노드, 깊이, 서브트리 노드 수를 구할 수 있다.