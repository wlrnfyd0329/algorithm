DP 문제 접근법
1. 테이블 정의하기 
2. 점화식 찾기
3. 초기값 정의하기

DP 방식
- Top-down : 재귀 + 메모이제이션
- Button-up : 배열을 정의, 점화식

DP
1. 하향식 접근으로 설계
2. 상태공간 트리 작성
    - 중복 호출 파악
3. 기저부터 상향식으로 뒤집어서 생각

트리 DP를 포함해서 DP 문제인 것 같다면 항상 상태를 정의해보자
해당 상태일 때, 아닐 때를 나눠서 table을 나눠서 정의하면 해결할 수 있을 것이다.

DAG(Directed Acyclic Graph) 방향성이 있고 순환하지 않는 그래프는 DP가 된다.
트리와 비슷하다고 볼 수 있지만 DAG는 마지막 지점에서 모일 수 있다.
즉 뒤로 돌아가지 않는, 앞으로만 가는, 사이클이 없는 그래프와 트리는 DP가 가능하다.

<LCS : Longest Common Substring, 최장 공통 문자열>
공통 문자열은 연속된 값이기에 공통된 문자가 끊기면 안된다.
따라서 달라지는 값이 있다면 바로 0으로 초기화 해준다.
이후, 최댓값을 찾는다. 보통 제일 마지막 값이 최댓값이다.

if i == 0 or j == 0:  # 마진 설정
	LCS[i][j] = 0
elif string_A[i] == string_B[j]:
	LCS[i][j] = LCS[i - 1][j - 1] + 1
else:
	LCS[i][j] = 0


<LCS : Longest Common Subsequence, 최장 공통 부분수열>
부분수열은 연속된 값이 아니기에 공통된 문자가 끊겨도 된다.
따라서 달라지는 값이 있다면 이전의 값을 가져와야 한다.
이후, 최댓값을 찾는다.

if i == 0 or j == 0:  # 마진 설정
	LCS[i][j] = 0
elif string_A[i] == string_B[j]:
	LCS[i][j] = LCS[i - 1][j - 1] + 1
else:
	LCS[i][j] = max(LCS[i - 1][j], LCS[i][j - 1])

<최장 공통 부분수열 찾기>
LCS 배열의 가장 마지막 값에서 시작한다.
1. 결과값을 저장할 result배열을 준비한다.
2. lcs[i - 1][j]와 lcs[i][j - 1] 중 현재 값과 같은 값을 찾는다. 
(아무 값이나 가도 되는 것은 어떤 값도 LCS가 될 수 있기 때문이다.)
    2 - 1. 만약 같은 값이 있다면 해당 값으로 이동한다.
    2 - 2. 같은 값이 없다면 result배열에 해당 문자를 넣고 lcs[i - 1][j - 1]로 이동한다.
3. 2번 과정을 반복하다가 0으로 이동하게 되면 종료하고 result의 역순이 정해다.