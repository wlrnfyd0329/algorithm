시간복잡도의 log는 log2()이다.
1'234'567'891 은 1억이 넘는 소수이다.
auto 를 사용하면 자동으로 변수 타입을 추론해서 세팅해준다. (C++11 이상)
v[1] ^= 1; // 방향 바꿔줌 0->1, 1->0, 2->3, 3->2

-------------------------------------------------------------------------------------------

#include <헤더 파일> // 컴파일러가 설치된 폴더에서 헤더 파일을 찾으라는 지시, 같은 경로에서 헤더 파일을 찾아라
#include "헤더 파일" // 사용자의 프로젝트 폴더나 개발자가 추가포함 디렉터리로 지정해준 경로에서 찾으라는 지시, 개발자가 만든 헤더 파일이나 추가로 외부 라이브러리를 포함하고 싶은 경우 사용
#define endl "\n" // 단순 치환, #은 전처리 지시자로 컴파일 이전에 수행하게 한다. #define 매크로이름 치환할값 으로 컴파일 이전에 치환하여 사용된다. 주의할 점은 ;을 붙이면 그것까지 치환되기에 주의해야 한다.
#define X first
#define Y second

typedef long long ll; // 새로운 자료형을 선언하는 것이다.
using ll = long long; // 위와 같은 역할을 하지만 using은 template<typename T>와 같은 템플릿화된 타입 별칭도 만들 수 있다는 것이다.

template<typename T>
class MyClass{}

using MC = MyClass<T>; // 템플릿화된 타입 별칭 예시

// 원래 namespace는 구역을 선언하는 데, 해당 구역의 객체를 명시하지 않고 사용할 수 있도록 해주는 코드다.
// 해당 코드가 없다면 std::로 std 구역에 해당하는 객체임을 명시해야 한다
using namespace std; 

namespace A {} // 이건 namespace를 구역을 선언하는 것이다. 안에 객체가 있다면 A::로 명시해야 한다

ios::sync_with_stdio(false); // C스타일(printf, scanf)와 C++스타일(cout, cin)의 동기화를 비활성화한다. 원래는 혼합해서 사용해도 되지만 해당 코드가 있으면 안된다. 입출력 속도가 빨라지는 효과가 있다.
// cin와 cout의 연결을 끊어준다. 원래 cout과 cin이 있다면 cout으로 출력된 후, cin을 입력할 수 있는데, 해당 코드로 cout 출력 전에 cin을 입력할 수 있다. 
// 즉 버퍼를 매번 비워 출력하는데, 그것을 나중에 한번에 비우도록 하는 것이다.
cin.tie(0); 

-------------------------------------------------------------------------------------------

<iostream>
입력
cin >> x;

출력
cout << x;
"\n" : 개행
"\t" : tap
"\b" : backspace (문자를 지우는 효과)
"\r" : 해당 열 앞으로 가는 효과
"\"" : "출력
"\'" : '출력
"\\" : \출력

-------------------------------------------------------------------------------------------

<algorithm>
pair<자료형, 자료형> 두 개의 값을 묶는 자료형
make_pair(a, b) 로 만들 수 있다.
{a, b} 로도 만들 수 있다.
swap(a, b) : 두 개의 값을 서로 바꾼다
max(a, b) : 두 개의 값 중 최댓값
max({a, b, c, ...}) 여러 개 값 중 최댓값
min(a, b) : 두 개의 값 중 최솟값
min({a, b, c, ...}) 여러 개 값 중 최솟값
max_element(시작 주소, 끝 주소) : array, arraylist에서 최댓값 iterator 반환
min_element(시작 주소, 끝 주소) : array, arraylist에서 최솟값 iterator 반환

reverse(시작 주소, 끝 주소) : 특정 범위의 원소들의 순서를 거꾸로 한다 // O(N)
sort(시작 주소, 끝 주소) : 정렬 // O(N logN);
bool cmp(const int &a, const int &b) {
    return a > b;
}
bool cmp() {}를 재정의할 수 있는데 넣을 때, cmp()가 아니라 cmp으로 넣어야 한다. 또한 const와  &를 붙여야 한다
sort(시작, 끝, cmp);

find(시작 주소, 끝 주소, 원하는 값) : 검색 // O(N)
lower_bound(시작 주소, 끝 주소, 원하는 값) : 원하는 값과 같거나 큰 값 중에 제일 작은 위치 // O(logN)
upper_bound(시작 주소, 끝 주소, 원하는 값) : 원하는 값보다 큰 값 중에 제일 작은 위치 // O(logN)
모두 없으면 마지막 반복자를 반환한다.
binary_search(시작 주소, 끝 주소, 원하는 값) : 이진 검색 bool 반환 // O(logN)
count(시작 주소, 끝 주소, 원하는 값) : 개수 // O(N)

next_permutation() : 특정 원소들의 다음 순열을 얻는다.

fill(시작 주소, 끝 주소, 원하는 값) : 특정 범위를 원하는 값으로 채운다 // O(N)
int arr[15];
fill(arr, arr + 15, n);

int arr[15][15];
fill(arr[0], arr[15], n); 

-------------------------------------------------------------------------------------------

<tuple>

tuple 초기화
tuple<자료형, 자료형, 자료형> t1(값, 값, 값); => 3개 이상도 된다.
tuple<자료형, 자료형, 자료형> t1;
t1 = make_tuple(값, 값, 값); => 이렇게 초기화해도 된다.

원소 접근
get<원소 index>(접근할 튜플의 이름);

tuple 원소 분해
tie(a, b, c) = t1;

-------------------------------------------------------------------------------------------

기본적인 형변환
1. int -> string : to_string()
int a = 100;
string s = to_string(a);

2. string -> int : stoi();
string s = "100";
int a = stoi(s);

3. int -> char
int a = 0;
char c = '9';
a = c - '0';

4. char -> int
int a = 9;
char c = (char)(a + 48);